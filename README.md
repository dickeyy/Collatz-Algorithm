# The Collatz Calculator

This is an algorithm custom built by Kyle Dickey, used to test numbers against the simple rules of the Collatz Conjecture.

## Get started 
To get started and try out the calculator for yourself, download the [Latest Release](https://github.com/dickeyy/Collatz-Calculator/releases). Extract the .zip file. There are a few different files you can try out, first, navigate to `src/calculator.py`, run this file for a console based calculator. This file allows the use of custom number inputs and a randomly generated number. Next, head over to `src/sequential.py`, this file simply starts at 1 and tests every number against the algorithm for infinity and saves it in `lastSuccessful.json` so when the script is restarted, it can start back from its last successful test instead of starting from 1. Lastly, go to `src/exe/CollatzCalculator.exe`, when this file is ran, it will open up a gui window and allow you to input a number to test, it will then report when the loop has been reached and how long it took (if the .exe doesn't work, run `src/guiCalc.py`).

## Sequential.py
There is also a file called Sequential.py (`src/sequetial.py`), in this file the algorithm goes through every number possible. It starts with 1 and will count up trying every number until it runs into a problem. The file will also create a file called `lastSuccessful.json` and store the last successfully tested number, incase the file crashes so it doesnt have to restart whenever the script is stopped. This file is really not very useful since every number up to like 260 quadrillion has been tested but its a cool proof of concept and I imagine if you put it on a server and let it run forever eventually it may be useful.

## What is the Collatz Conjecture?
 The conjecture states: You take any positive integer, 1-infinity, and apply two simple rules to it, those rules being if the number you have is even then divide it by two, if its odd then multiply by three and add one you keep doing this with each new number that you get based of the result of the rule that you just applied,
for example, **10**, 10 is even so divide by 2 and you get **5** thats odd so times 3 add one is **16** thats even so divide by 2 thats **4** divide by 2 again and you get **1** thats odd so multiply by 3 and add 1, but wait thats **4**... see the loop? The conjecture states that all positive numbers will eventually come back to this **4-2-1-4** loop after applying the two rules however many times. So far mathematicians have yet to find a number that breaks this rule and every number all the way up to like 300 quintillion has been tested or something so, so far there isn't a number that goes against this conjecture. 

## About this Algorithm
This is likely not as efficient as it could be and there is probably some ways I messed up. Also, the algorithm could be a lot shorter (something like 10 lines total) but i included all the other stuff to communicate with the user and all that. All that being said, the algorithm does work and it will test any number you want in fractions of a second. 